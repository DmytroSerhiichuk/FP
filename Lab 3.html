<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="assets/style.css">
    <title>Lab 3</title>
</head>

<body>
    <div class="navigation-container">
        <nav class="lab-nav">
            <a href="index.html">Титулка</a>
            <a href="Lab 1.html">Lab 1</a>
            <a href="Lab 2.html">Lab 2</a>
            <a href="Lab 3.html">Lab 3</a>
            <a href="Lab 4.html">Lab 4</a>
            <a href="Lab 5.html">Lab 5</a>
            <a href="Lab 6.html">Lab 6</a>
            <a href="Lab 7.html">Lab 7</a>
        </nav>

        <nav class="page-nav">
            <a href="#goal">Мета</a>
            <a href="#conditions">Умова</a>
            <a href="#analysis">Аналіз</a>
            <a href="#hipo" id="hipo-ref">HIPO Діаграма</a>
            <a href="#code-section">Код</a>
            <a href="#results">Результати</a>
            <a href="#validation">Перевірка</a>
            <a href="#ai">Перевірка коду ШІ</a>
            <a href="#conclusion">Висновок</a>
        </nav>
    </div>

    <header>
        <h1>Lab 3</h1>
    </header>

    <div id="main-wrapper">
        <main>
            <details id="goal" open>
                <summary>Мета</summary>
                <p>Розв’язати нелінійні рівняння та здійснити чисельне інтегрування функцій наближеними методами, використовуючи мови функціонального програмування та lambda, let та set! форми.</p>
            </details>
            <details id="conditions" open>
                <summary>Умова</summary>
                <img src="assets/images/lab3-conditions1.png">
<img src="assets/images/lab3-conditions2.png">
<img src="assets/images/lab3-conditions3.png">
            </details>
            <details id="analysis" open>
                <summary>Аналіз</summary>
                <h4>Завдання 1</h4>

<p>
    Для реалізації методу перебору необхідно вказати проміжок [a; b] та крок зміни. Суть даного ітераційного метода полягає в тому, 
    що ми поступово збільшуємо значення a на значення кроку, поки не досягнемо значення b. На кожній ітерації множимо поточне значення 
    a на попереднє, якщо результат менший за 0, то це означає, що між цими точками знаходиться корінь рівняння
</p>

<p>
    Метод простої ітерації потребує визначення початкової точки, а також точності вимірювання. Для цього метода потрібно перетворити формулу 
    до вигляду: x = φ(x), у нашому випадку, формула з умови перетвориться до такого вигляду: <strong>x = √(cos(x))</strong>. На кожній ітерації знаходиться 
    модуль різниця між попереднім значенням x та новим nex-x (обчислюється як результат передачі x до функції), якщо це значення менше за вказану точність, то 
    повертається new-x, інакше - ітераційний процес продовжується, де до значення x записується new-x.
</p>

<h4>Завдання 2</h4>

<p>
    Для реалізації методу трапецій потрібно вказати кількість відрізків n - це значення буде визначати точність обчислення. Інтервал інтегралу [a; b] 
    розбивається на n значень, які передається до функції інтегралу. Кожне значення, де x ∈ [1, n - 1] множиться на 2. Всі отримані значення сумуються 
    між собою, після чого множаться на (b - a)/2n
</p>
            </details>
            <details id="hipo" open>
                <summary>HIPO Діаграма</summary>
                
            </details>
            <details id="code-section" open>
                <summary>Код</summary>
                <div id="code-wrapper-container">
                    <code class="code">
                        <div class="copy-code-top-container">
                            Code: Task1
                            <button class="copy-code-btn">
                                <img class="copy-code-icon" src="assets/copy-icon.svg">
                            </button>
                        </div>
                        
                        <pre class="code-text">#lang racket

(displayln "Лаб 3 (Варіант 11) - Завданя 1")
(displayln "Виконав - Сергійчук Дмитро (Підгрупа 6)")
(newline)

(define (f x)
  (- (expt x 2) (cos x)))

(define (g x)
  (sqrt (cos x)))

(define (fixed-point-iteration func x precision [max-iter 1000])
  (set! iterations (+ iterations 1))
  (let* ([new-x (func x)]
         [diff (abs (- new-x x))])
    (if (or (<= diff precision) (>= iterations max-iter))
      new-x
      (fixed-point-iteration func new-x precision))))

(define (brute-force func a b step)
  (set! iterations (+ iterations 1))
  (let* ([new-a (+ a step)]
        [res1 (func a)]
        [res2 (func new-a)]
        [multiplication-result (* res1 res2)])
    (if (< multiplication-result 0)
      new-a
      (brute-force func new-a b step))))

(displayln "Пошук кореня нелінійного рівняння x^2 - cos(x):")
(displayln "-----------------------------------------------")

(define ANSWER 0.82413231230252242296)
(printf "Реальне значення: ~a\n\n" ANSWER)

(define iterations 0)

(define fixed-point-result (fixed-point-iteration g 0 0.001))
(define fixed-point-result-error (abs (- fixed-point-result ANSWER)))
(displayln "Метод простої ітерації:")
(printf "Результат: ~a\nКількість ітерацій: ~a\nПохибка: ~a\n\n" fixed-point-result iterations fixed-point-result-error)

(set! iterations 0)

(define brute-force-result (brute-force f 0.5 1 0.01))
(define brute-force-result-error (abs (- brute-force-result ANSWER)))
(displayln "Метод перебору:")
(printf "Результат: ~a\nКількість ітерацій: ~a\nПохибка: ~a\n\n" brute-force-result iterations brute-force-result-error)</pre>
                    </code>

                    <code class="code code-2">
                        <div class="copy-code-top-container">
                            Code: Task 2
                            <button class="copy-code-btn">
                                <img class="copy-code-icon" src="assets/copy-icon.svg">
                            </button>
                        </div>
                        
                        <pre class="code-text code-text-2">#lang racket

(displayln "Лаб 3 (Варіант 11) - Завданя 2")
(displayln "Виконав - Сергійчук Дмитро (Підгрупа 6)")
(newline)

(define (integral-func x)
  (/ (cos x) (sqrt x)))

(define (trapezoidal-rule func a b n)
  (let* ([range (- b a)]
         [step (/ range n)])
    (define calc-sum (lambda (sum current max)
      (if (< current max)
        (calc-sum (+ sum (* 2 (func current))) (+ current step) max)
        sum)))
    (* (/ range (* 2 n)) (+ (func a) (calc-sum 0 (+ a step) (- b step)) (func b)))))

(define (simpsons-rule func a b)
  (let ([h (/ (- b a) 2)])
    (* (/ h 3) (+ (func a) (* 4 (func (+ a h))) (func b)))))

(displayln "Обчислення інтегралу:")
(displayln "---------------------")

(define ANSWER 1.256425664460123)
(printf "Реальне значення: ~a\n\n" ANSWER)

(define A 0.1)
(define B 2)

(define trapezoidal-result (trapezoidal-rule integral-func A B 100))
(define trapezoidal-result-error (abs (- trapezoidal-result ANSWER)))
(displayln "Метод трапцій:")
(printf "Результат: ~a\nПохибка: ~a\n\n" trapezoidal-result trapezoidal-result-error)

(define simpsons-rule-result (simpsons-rule integral-func A B))
(define simpsons-rule-result-error (abs (- simpsons-rule-result ANSWER)))
(displayln "Метод Сімпсона")
(printf "Результат: ~a\nПохибка: ~a" simpsons-rule-result simpsons-rule-result-error)
</pre>
                    </code>
                </div>
            </details>
            <details id="results" open>
                <summary>Результати</summary>
                <h4>Завдання 1</h4>

<p>Для порівняння результатів використовується кількість виконаних ітерацій та порівнянння з реальним значенням</p>

<img src="assets/images/lab3-result1.png" alt="">

<h4>Завдання 2</h4>

<p>Для порівняння результатів використовується порівнянння з реальним значенням інтегралу</p>

<img src="assets/images/lab3-result2.png" alt="">
            </details>
            <details id="validation" open>
                <summary>Перевірка</summary>
                <h4>Завдання 1</h4>

<p>Для отримання реального значення кореня, для перевірки отриманих результатів, було використано даний <a href="https://www.wolframalpha.com/input?i2d=true&i=Power%5Bx%2C2%5D-cos%5C%2840%29x%5C%2841%29">сайт</a>.</p>

<img src="assets/images/lab3-validation1.png" alt="">

<h4>Завдання 2</h4>

<p>Для отримання реального значення інтегралу, для перевірки отриманих результатів, було використано даний <a href="https://www.wolframalpha.com/input?i2d=true&i=Integrate%5BDivide%5Bcos%5C%2840%29x%5C%2841%29%2CSqrt%5Bx%5D%5D%2C%7Bx%2C0.1%2C2%7D%5D">сайт</a>.</p>

<img src="assets/images/lab3-validation2.png" alt="">
            </details>
            <details id="ai" open>
                <summary>Перевірка коду ШІ</summary>
                <h4>Завдання 1</h4>

<p>Введний запит: "чи відповідає даний код на мові програмування racket критеріям простоти та clean code? (код завдання №1)"</p>

<p>Відповідь Chat GPT</p>

<p>✅ Плюси:</p>

<ol>
    <li>Прості та зрозумілі функції f і g — коротко і без зайвого коду.</li>
    <li>Видно структуру програми: спочатку функції, потім основна логіка з викликами, в кінці — вивід результатів.</li>
    <li>Використано іменовані параметри (наприклад, [max-iter 1000] із значенням за замовчуванням).</li>
    <li>Код лаконічний — немає надто довгих виразів чи дублювання</li>
</ol>

<p>⚠️ Мінуси з погляду clean code:</p>

<ol>
    <li>
        Глобальна змінна iterations:
        <ul>
            <li>Ти використовуєш set! iterations усередині рекурсивних функцій. Це робить функції нечистими (вони змінюють зовнішній стан).</li>
            <li>У функціональних мовах, і зокрема у Racket, краще повертати кількість ітерацій разом із результатом, а не використовувати глобальну змінну.</li>
            <li>Через це функції важче тестувати ізольовано</li>
        </ul>
    </li>
    <li>
        Назви функцій і змінних:
        <ul>
            <li>res1, res2, multiplication-result можна зробити більш семантичними (наприклад, fa, fb, sign-change).</li>
        </ul>
    </li>
    <li>
        Дублювання логіки:
        <ul>
            <li>І в fixed-point-iteration, і в brute-force є підрахунок ітерацій і рекурсія з новим параметром. Це можна було б винести в окремий "хелпер" або ж реалізувати через локальні функції (let loop), без глобальної змінної.</li>
        </ul>
    </li>
    <li>
        Стиль:
        <ul>
            <li>Місцями зайві порожні рядки</li>
            <li>displayln і printf впереміш — краще уніфікувати стиль виводу</li>
        </ul>
    </li>
</ol>

<p>🔄 Як можна зробити чистіше (і більш "функціонально"):</p>

<p>Замість глобальної змінної iterations, можна робити так:</p>

<div id="code-wrapper-container">
    <code class="code">
        <div class="copy-code-top-container">
            Code
            <button class="copy-code-btn">
                <img class="copy-code-icon" src="assets/copy-icon.svg">
            </button>
        </div>
        
        <pre class="code-text">
(define (fixed-point-iteration func x precision [max-iter 1000])
  (let loop ([x x] [iter 0])
    (let* ([new-x (func x)]
           [diff (abs (- new-x x))])
      (if (or (<= diff precision) (>= iter max-iter))
          (values new-x iter)  ; повертаємо і результат, і кількість ітерацій
          (loop new-x (add1 iter))))))
        </pre>
    </code>
</div>

<p>І потім викликати:</p>

<div id="code-wrapper-container">
    <code class="code">
        <div class="copy-code-top-container">
            Code
            <button class="copy-code-btn">
                <img class="copy-code-icon" src="assets/copy-icon.svg">
            </button>
        </div>
        
        <pre class="code-text">
(define-values (fixed-point-result iterations)
  (fixed-point-iteration g 0 0.001))
        </pre>
    </code>
</div>

<p>Те ж саме для brute-force.</p>

<p>🔚 Висновок</p>

<p>Код у тебе простий і зрозумілий для початкового рівня, але з точки зору clean code у Racket є проблеми:</p>

<ul>
    <li>глобальна змінна iterations,</li>
    <li>нечисті функції</li>
    <li>кілька не дуже вдалих назв</li>
    <li>дрібні стилістичні неточності</li>
</ul>

<p>Якщо зробити рекурсію "чистою" (через внутрішній цикл loop) і уникати глобальних змінних, код буде відповідати функціональному стилю та вважатись clean</p>

<h4>Завдання 2</h4>

<p>Введний запит: "чи відповідає даний код на мові програмування racket критеріям простоти та clean code? (код завдання №2)"</p>

<p>✅ Що добре:</p>

<ol>
    <li>Функції мають зрозумілі назви: integral-func, trapezoidal-rule, simpsons-rule. Це одразу пояснює, що вони роблять</li>
    <li>Мінімум глобальних змінних: усі обчислення виконуються через функції, без set! чи змінювання стану.</li>
    <li>Функції короткі й роблять одну задачу — це відповідає принципу single responsibility</li>
    <li>Чітка структура коду: спочатку визначення функцій, далі — вивід результатів</li>
</ol>

<p>⚠️ Моменти для покращення:</p>

<ol>
    <li>
        Стиль рекурсії в trapezoidal-rule
        <ul>
            <il>Ти використав define calc-sum як рекурсивну лямбду всередині let*. Це працює, але виглядає трохи заплутано.</il>
            <il>У Racket прийнято робити локальні рекурсивні функції через let loop, щоб було зрозуміло, що це саме цикл.</il>
        </ul>

        <p>Наприклад</p>

        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                
                <pre class="code-text">
(let loop ([sum 0] [current (+ a step)])
  (if (< current (- b step))
      (loop (+ sum (* 2 (func current))) (+ current step))
      sum))
                </pre>
            </code>
        </div>

        <p>Це читабельніше й звичніше для Racket</p>
    </li>
    <li>
        Назви змінних
        <ul>
            <li>range краще назвати interval або width, бо range часто асоціюється з колекціями (послідовностями).</li>
            <li>calc-sum звучить як функція в загальному сенсі, але насправді це конкретна локальна рекурсія. Краще loop чи sum-loop.</li>
        </ul>
    </li>
    <li>
        Вивід результатів (displayln + printf)
        <ul>
            <li>Ти змішуєш displayln і printf. Це не помилка, але для чистоти стилю краще вибрати один підхід.</li>
            <li>Якщо хочеш красиве форматування → краще всюди printf. Якщо простий вивід тексту → всюди displayln</li>
        </ul>
    </li>
    <li>
        Структура програми
        <ul>
            <li>Було б чистіше винести вивід результатів у окрему функцію, наприклад print-results, щоб розділити логіку обчислень і вивід</li>
        </ul>
    </li>
</ol>

<p>🔄 Як можна зробити ще чистіше</p>

<p>Ось твій код трохи перероблений у стилі "clean Racket":</p>

<div id="code-wrapper-container">
    <code class="code">
        <div class="copy-code-top-container">
            Code
            <button class="copy-code-btn">
                <img class="copy-code-icon" src="assets/copy-icon.svg">
            </button>
        </div>
        
        <pre class="code-text">
#lang racket

(define (integral-func x)
  (/ (cos x) (sqrt x)))

(define (trapezoidal-rule func a b n)
  (define step (/ (- b a) n))
  (define (loop sum current)
    (if (< current (- b step))
        (loop (+ sum (* 2 (func current))) (+ current step))
        sum))
  (* (/ (- b a) (* 2 n))
     (+ (func a) (loop 0 (+ a step)) (func b))))

(define (simpsons-rule func a b)
  (define h (/ (- b a) 2))
  (* (/ h 3)
     (+ (func a) (* 4 (func (+ a h))) (func b))))

(define (print-result name value exact)
  (define error (abs (- value exact)))
  (printf "~a:\n  Результат: ~a\n  Похибка: ~a\n\n" name value error))

;; --- Основна програма ---
(displayln "Обчислення інтегралу:")
(displayln "---------------------")

(define ANSWER 1.256425664460123)
(printf "Реальне значення: ~a\n\n" ANSWER)

(define A 0.1)
(define B 2)

(print-result "Метод трапецій"
              (trapezoidal-rule integral-func A B 100)
              ANSWER)

(print-result "Метод Сімпсона"
              (simpsons-rule integral-func A B)
              ANSWER)
        </pre>
    </code>
</div>

<p>🔚 Висновок</p>

<p>Твій код загалом відповідає принципам простоти і clean code — він зрозумілий, не перевантажений і не використовує глобальних змінних.
Але є простір для вдосконалення: чистіша рекурсія через let loop, узгоджений стиль виводу, кращі назви змінних і винесення виводу в окрему функцію.</p>
            </details>
            <details id="conclusion" open>
                <summary>Висновок</summary>
                <p>
    Під час виконання даної роботи було продемонстровано роботу з <strong>let</strong>, <strong>let*</strong>, <strong>set!</strong> та <strong>lamda</strong>. 
</p>
<p>
    Функції let та let* зручно використовувати для оголошення внутрішніх змінних в тілі функцій. Відмінність let від let* заключається в тому, що якщо ми 
    оголошуємо декілька змінних одночасно, і нам необхідно використовувати значення попердніх змінних, то у звичайному let це можливо лише з використанням вкладених 
    let. В let* ми маємо доступ до попередніх змінних
</p>
<p>
    Функція set! призначена для перевизначення значення змінної. В даній роботі вона використовується для перевизначення глобальної змінної <strong>iterations</strong>, 
    яка використовується в 1 завданні для зберігання кількості ітерацій, які було виконано кожним методом
</p>
<p>
    Ключове слово lambda довзоляє визначити анонімні функції. Це зручно використовувати при передачі функцій, як аргументів функцій, але в даній роботі це не було використано
</p>
            </details>
        </main>
    </div>

    <script src="assets/script.js"></script>
</body>

</html>