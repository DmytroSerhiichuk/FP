<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="assets/style.css">
    <title>Lab 2</title>
</head>

<body>
    <div class="navigation-container">
        <nav class="lab-nav">
            <a href="index.html">Титулка</a>
            <a href="Lab 1.html">Lab 1</a>
            <a href="Lab 2.html">Lab 2</a>
            <a href="Lab 3.html">Lab 3</a>
            <a href="Lab 4.html">Lab 4</a>
            <a href="Lab 5.html">Lab 5</a>
            <a href="Lab 6.html">Lab 6</a>
            <a href="Lab 7.html">Lab 7</a>
            <a href="Lab 8.html">Lab 8</a>
        </nav>

        <nav class="page-nav">
            <a href="#goal">Мета</a>
            <a href="#conditions">Умова</a>
            <a href="#analysis">Аналіз</a>
            <a href="#hipo" id="hipo-ref">HIPO Діаграма</a>
            <a href="#code-section">Код</a>
            <a href="#results">Результати</a>
            <a href="#validation">Перевірка</a>
            <a href="#ai">Перевірка коду ШІ</a>
            <a href="#conclusion">Висновок</a>
        </nav>
    </div>

    <header>
        <h1>Lab 2</h1>
    </header>

    <div id="main-wrapper">
        <main>
            <details id="goal" open>
                <summary>Мета</summary>
                <p>
    Сформувати декларативне мислення в галузі програмування завдяки застосуванню принципів функціонального програмування. Опанувати техніку застосування рекурсивних функцій для обчислювальних процесів і здійснити дослідження ефективності рекурсивних процесів.</p>
</p>
            </details>
            <details id="conditions" open>
                <summary>Умова</summary>
                <img src="assets/images/lab2-conditions.png">
            </details>
            <details id="analysis" open>
                <summary>Аналіз</summary>
                <h4>Завдання 1</h4>

<p>
    Для виконання даного завдання, потрібно реалізувати знаходження косинуса за допомогою ряду Тейлора:
</p>

<img src="assets/images/lab2-analyse1.png"/>

<p>
    Ця функція вимагає пошуку факторіала числа, що можна реалізувати за допомогою хвостової рекурсії. 
    Рекурсія має акумулятор <em>acc</em>, який позначає попереднє значення факторіала (початкове значення 1), 
    поточну ітерацію <em>current</em> (початкове значення 1), а також число <em>n</em>, для якого потрібно знайти факторіал. 
    Поки current менше за n, то виконується повторний виклик рекурсії, де acc обчислюється через множення попереднього значння на current. 
    Якщо current досяг n, то повертаємо acc помножене на current. 
</p>

<h4>Завдання 2</h4>

<p>Нескінченний дріб, для визначення <em>e</em> має такий вигляд:</p>

<img src="assets/images/lab2-analyse2.png"/>

<p>
    Потрібно реалізувати функцію для обчислення даного дробу до n вкладувань. 
    Це можна реалізувати через розділення дробу на функції вигляду: <strong>d + 1/x</strong>, де <em>d</em> - належить послідовності: 
    [2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, ...], x - функція з наступним значенням d з послідовності.
</p>
<p>
    Далі створюється рекурсивна функція, яка приймає попереднє значення дробу - val (початкове значення 2), 
    поточну ітерацію = індекс d - iter (початкове значення 1), функцію func (початкове значення 2 + 1/x) і точність обчислення. 
    На кожному рівні рекурсії обчислюється <em>next-d</em> - наступне d з послідовності. До функції func передається next-d, результат чого 
    використовується як поточне значення нескінченного дробу. Якщо модуль різниці даного значення та val менший за точність, 
    то рекусрія завершується, інакше до наступного рівня рекурсії передається нова функція вигляду: func(next-d + 1/x), що просуває обчислення 
    нескінченного дробу на один рівень глибше
</p>
            </details>
            <details id="hipo" open>
                <summary>HIPO Діаграма</summary>
                <h4>Завдання 1</h4>

<img src="assets/images/lab2-hipo1.png" alt="">

<h4>Завдання 2</h4>

<img src="assets/images/lab2-hipo2.png" alt="">
            </details>
            <details id="code-section" open>
                <summary>Код</summary>
                <div id="code-wrapper-container">
                    <code class="code">
                        <div class="copy-code-top-container">
                            Code: Task1
                            <button class="copy-code-btn">
                                <img class="copy-code-icon" src="assets/copy-icon.svg">
                            </button>
                        </div>
                        
                        <pre class="code-text">#lang racket

(displayln "Лаб 2 (Варіант 11) - Завданя 1")
(displayln "Виконав - Сергійчук Дмитро (Підгрупа 6)")

(newline)

(define (set-precision)
	(display "Введіть точність обчислення від 10^-2 до 10^-6: ")
	(define precision (read))
	(if (and (>= precision 10e-6) (<= precision 10e-2))
		precision
		(begin
			(displayln "Введена точність не входить у діапазон [10^-6; 10^-2]")
			(set-precision))))

(define (factorial n [acc 1] [current 1])
	(cond
		[(= current n) (* acc current)]
		[else (factorial n (* acc current) (+ current 1))]))

(define (my-cos x precision [value 1] [prev 0] [sign #false] [k 2])
	(define diff (abs (- value prev)))
	(cond
		[(< diff precision) value]
		[else 
			(define v (/ (expt x k) (factorial k)))
			(if sign
				(my-cos x precision (+ value v) value #false (+ k 2))
				(my-cos x precision (- value v) value #true (+ k 2)))
		]))

(define (find-y x cos-func)
	(cond
		[(and (<= -1 x) (<= x 1))
			(* (expt (cos-func x) 2) (cos-func (expt x 2)))]
		[(and (< 1 x) (<= x 2))
			(/ (cos-func (/ x 2)) (cos-func (+ x 0.5)))]
		[else #false]))

(define (format-value val prec max)
	(if (< val 0)
		(~r val #:precision (- prec 1) #:min-width (- max 1))
		(~r val #:precision prec #:min-width max)))

(define (iterate-x current max step precision)
	(define (my-cos-wrapper x)
		(my-cos x precision))

	(define not-found-message "Не визначено")
	(define not-found-message-length (string-length not-found-message))
	(define prec (min 10 (- not-found-message-length 2)))
	(define x-prec 8)

	(printf "+----------+--------------+--------------+--------------+\n")
	(printf "|        x |       Тeйлор |   Стандартне |      Похибка |\n")
	(printf "+----------+--------------+--------------+--------------+\n")

	(define (iterate-x-inner current max step)
		(define real (find-y current cos))
		(define est (find-y current my-cos-wrapper))

		(define x-str (format-value current x-prec x-prec))

		(cond
			[(number? est)
				(define est-str (format-value (exact->inexact est) prec not-found-message-length))
				(define real-str (format-value real prec not-found-message-length))

				(define err (exact->inexact (abs (- real est))))
				(define err-str (format-value err prec not-found-message-length))
				(printf "| ~a | ~a | ~a | ~a |\n" x-str est-str real-str err-str)]
			[else 
				(printf "| ~a | ~a | ~a | ~a |\n" x-str not-found-message not-found-message not-found-message)])
		
		(cond
			[(<= (+ current step) max) 
				(iterate-x-inner (+ current step) max step)]))
	
	(iterate-x-inner current max step)
	(printf "+----------+--------------+--------------+--------------+\n"))

	
(define precision (set-precision))
(newline)
(display "Введіть початкове значення x: ")
(define x1 (read))
(display "Введіть кінцеве значення x: ")
(define x2 (read))
(display "Введіть крок зміни x: ")
(define step (read))
(newline)

(if (< x1 x2)
	(iterate-x x1 x2 step precision)
	(iterate-x x2 x1 step precision))</pre>
                    </code>

                    <code class="code code-2">
                        <div class="copy-code-top-container">
                            Code: Task 2
                            <button class="copy-code-btn">
                                <img class="copy-code-icon" src="assets/copy-icon.svg">
                            </button>
                        </div>
                        
                        <pre class="code-text code-text-2">#lang racket

(displayln "Лаб 2 (Варіант 11) - Завданя 2")
(displayln "Виконав - Сергійчук Дмитро (Підгрупа 6)")

(newline)

(define (set-precision)
	(display "Введіть точність обчислення від 10^-2 до 10^-10: ")
	(define precision (read))
	(if (and (>= precision 10e-10) (<= precision 10e-2))
		precision
		(begin
			(displayln "Введена точність не входить у діапазон [10^-10; 10^-2]")
			(set-precision))))

(define (find-e precision [val 2] [func (lambda (x) (+ 2 (/ 1 x)))] [iter 1])
  (define next-denominator (cond 
    [(= iter 1) 1]
    [(= iter 2) 2]
    [(= (modulo (- iter 2) 3) 0) (* (/ (- iter 2) 2) 2)]
    [else 1]))

  (define next (func next-denominator))

  (cond
    [(<= (abs (- val next)) precision) next]
    [else
      (define (next-fun x)
        (+ next-denominator (/ 1 x)))
      (find-e precision next (lambda (x) (func (next-fun x))) (+ iter 1))]))


(define precision (set-precision))

(define est (exact->inexact (find-e precision)))
(define real (exp 1))

(printf "Обчислене значення: ~a\n" est)
(printf "Стандартне значення e: ~a\n" real)
(printf "Похибка: ~a" (abs (- real est)))</pre>
                    </code>
                </div>
            </details>
            <details id="results" open>
                <summary>Результати</summary>
                <img src="assets/images/lab2-result1.png">
<img src="assets/images/lab2-result2.png">
            </details>
            <details id="validation" open>
                <summary>Перевірка</summary>
                <p>
    Завдання не потребують окремої перевірки. Серед результатів вже демонструється похибка вимірювань, 
    що показує досить незначне відхидення від результатів, отриманих через використання станадартних функцій 
    для обчислення косинуса та значення <em>e</em>. Це можна вважати підтвердженням коректності реалізації функцій
</p>
            </details>
            <details id="ai" open>
                <summary>Перевірка коду ШІ</summary>
                <h4>Завдання 1</h4>

<p>Введний запит: "чи відповідає даний код на мові програмування racket критеріям простоти та clean code? (код завдання №1)"</p>

<p>Відповідь Chat GPT</p>

<p>✅ Позитивні моменти:</p>

<ol>
    <li>Структурованість — код логічно поділений на функції з чіткими завданнями: set-precision, factorial, my-cos, find-y, format-value, iterate-x. Це добре.</li>
    <li>Рекурсивний стиль — відповідає ідеології Racket/Lisp, виглядає природно.</li>
    <li>Використання додаткових аргументів у рекурсії (factorial, my-cos) для акумуляції результатів — це ефективний підхід.</li>
    <li>Перевірки на коректність введення (set-precision) — хороший знак уваги до надійності.</li>
    <li>Форматований вивід таблиці — виглядає чисто, не хаотично.</li>
</ol>

<p>⚠️ Можливі проблеми з clean code:</p>

<ol>
    <li>
        Змішування вводу/виводу та логіки
        <ul>
            <li>У функціях set-precision, iterate-x є і читання/друк, і обчислення. Це ускладнює повторне використання коду.</li>
            <li>Краще розділити: функції повинні або рахувати, або відповідати за IO, але не обидва разом.</li>
        </ul>
    </li>
    <li>
        Невдале іменування:
        <ul>
            <li>my-cos — виглядає як тимчасове ім’я. Краще назвати taylor-cos чи approx-cos.</li>
            <li>find-y не пояснює, що саме обчислюється (наприклад, можна назвати compute-y чи piecewise-function).</li>
            <li>iterate-x більше схоже на цикл, а не на функцію, що повертає результат. Можна перейменувати в print-results-for-x-range.</li>
        </ul>
    </li>
    <li>
        set-precision — рекурсивний виклик для повторного вводу
        Це працює, але виглядає трохи “грубувато”. У більш чистому варіанті варто мати цикл для повторного вводу, щоб було зрозуміліше.
    </li>
    <li>
        Магічні числа:
        <ul>
            <li>10e-6, 10e-2 краще винести у константи MIN-PRECISION, MAX-PRECISION.</li>
            <li>Ширина колонок у таблиці (+----------+...) теж могла б бути константами.</li>
        </ul>
    </li>
    <li>
        Умови if та cond трохи перевантажені - У деяких місцях можна спростити логіку. Наприклад, у my-cos замість if sign ... else ... можна використати множник sign (+1/-1).
    </li>
</ol>

<p>✨ Як можна зробити простіше і чистіше:</p>

<ul>
    <li>Винести обчислювальні функції (factorial, taylor-cos, find-y) окремо від ввід/вивід функцій.</li>
    <li>Використовувати більш зрозумілі імена (taylor-cos, compute-piecewise-y, print-results).</li>
    <li>Замість рекурсії для set-precision зробити цикл введення.</li>
    <li>Винести "магічні значення" у константи.</li>
</ul>

<p>👉 Загальний висновок:</p>

<p>Код працює і читається, але він більше схожий на навчальний приклад, ніж на чистий production-код. Для критеріїв простоти – так, відповідає. Для clean code – місцями бракує відокремлення логіки від вводу/виводу та кращих імен.</p>

<h4>Завдання 2</h4>

<p>Введний запит: "чи відповідає даний код на мові програмування racket критеріям простоти та clean code? (код завдання №2)"</p>

<p>✅ Плюси коду:</p>

<ol>
    <li>
        Структурованість - Є окрема функція для точності (set-precision) і окрема — для обчислення e (find-e). Це добре.
    </li>
    <li>
        Рекурсивний підхід - В find-e правильно використовується рекурсія для обчислення наближення
    </li>
    <li>
        Чистота коду - Код виглядає акуратно, без зайвих вкладень чи дублювань, легко простежити логіку
    </li>
    <li>
        Валідність введення - У set-precision є перевірка діапазону та повторний запит при некоректному введенні.
    </li>
</ol>

<p>⚠️ Недоліки щодо clean code:</p>

<ol>
    <li>
        Змішування вводу/виводу та логіки - set-precision читає дані і перевіряє їх. Краще відділити: одна функція читає користувацьке введення, інша перевіряє його.
    </li>
    <li>
        Іменування
        <ul>
            <li>find-e — зрозуміло, але можна уточнити (approx-e або continued-fraction-e).</li>
            <li>val та func звучать занадто загально. Варто дати імена, які передають сенс (наприклад, current-value, fraction-func).</li>
            <li>next-denominator гарна назва, але сама логіка в cond виглядає трохи громіздкою. Її можна винести у функцію compute-denominator.</li>
        </ul>
    </li>
    <li>
        Магічні числа - Діапазон точності (10e-10, 10e-2) варто винести в константи, наприклад MIN-PRECISION, MAX-PRECISION.
    </li>
    <li>
        Вивід результату прямо в коді - Код завершується друком результатів. У чистому стилі краще відділити обчислення (функції) від форматування/виводу
    </li>
    <li>
        Рекурсивний set-precision - Як і у попередньому коді, повторний виклик функції для введення виглядає менш чисто, ніж цикл з перевіркою.
    </li>
</ol>

<p>✨ Поради для покращення clean code:</p>

<ul>
    <li>Винести магічні значення (10e-10, 10e-2) у константи</li>
    <li>Перейменувати змінні (val, func) у більш зрозумілі</li>
    <li>Відокремити логіку обчислення від вводу/виводу (щоб find-e можна було використовувати незалежно від консолі)</li>
    <li>Замість рекурсії у set-precision краще зробити цикл запиту</li>
</ul>

<p>👉 Висновок:</p>

<p>Код простий і досить акуратний, він читається й не перевантажений. Але до ідеального clean code йому бракує: кращих імен, відсутності “магічних чисел” та розділення вводу/виводу від логіки.</p>
            </details>
            <details id="conclusion" open>
                <summary>Висновок</summary>
                <p>
    Під час виконання даної роботи були покращенні вміння роботи з умовами в racket. Також було продемонстровано роботу з форматуванням тексту 
    через використання <strong>~r</strong>, а також використання значень за замовчуванням для аргументів функцій, що особливо корисно для уникнення 
    помилок під час виклику функцій, які використовують акумулятори, де початкове значення строго визначене.
</p>
            </details>
        </main>
    </div>

    <script src="assets/script.js"></script>
</body>

</html>