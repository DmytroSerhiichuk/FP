<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="assets/style.css">
    <title>Lab 1</title>
</head>

<body>
    <div class="navigation-container">
        <nav class="lab-nav">
            <a href="index.html">Титулка</a>
            <a href="Lab 1.html">Lab 1</a>
            <a href="Lab 2.html">Lab 2</a>
            <a href="Lab 3.html">Lab 3</a>
            <a href="Lab 4.html">Lab 4</a>
            <a href="Lab 5.html">Lab 5</a>
            <a href="Lab 6.html">Lab 6</a>
        </nav>

        <nav class="page-nav">
            <a href="#goal">Мета</a>
            <a href="#conditions">Умова</a>
            <a href="#analysis">Аналіз</a>
            <a href="#hipo" id="hipo-ref">HIPO Діаграма</a>
            <a href="#code-section">Код</a>
            <a href="#results">Результати</a>
            <a href="#validation">Перевірка</a>
            <a href="#ai">Перевірка коду ШІ</a>
            <a href="#conclusion">Висновок</a>
        </nav>
    </div>

    <header>
        <h1>Lab 1</h1>
    </header>

    <div id="main-wrapper">
        <main>
            <details id="goal" open>
                <summary>Мета</summary>
                <p>Сформувати декларативне мислення в галузі програмування завдяки застосуванню принципів функціонального програмування. Опанувати техніку застосування рекурсивних функцій для обчислювальних процесів і здійснити дослідження ефективності рекурсивних процесів.</p>
            </details>
            <details id="conditions" open>
                <summary>Умова</summary>
                <img src="assets/images/lab1-conditions.png">
            </details>
            <details id="analysis" open>
                <summary>Аналіз</summary>
                <h4>Завдання 1</h4>

<p>
    Для знаходження n-ого елемента послідовносі було потрібно реалізувати 3 функції. Хвостова рекурсія та ітеративний процес, по суті, є однаковою функцію, яку можна реалізувати таким чином: 
    створюється додаткова функція-ітератор, яка має два акумулятори (останнє та передостаннє числа), а також індекс поточної ітерації. Дана функція повертає значення <em>a</em>, якщо лічильник 
    ітерацій досяг значення <em>n</em>, інакше виконується повторний виклик даної функції, де аргументу <em>a</em> присвоюється значення суми <em>a</em> та <em>b</em>, а аргументу <em>b</em> 
    передається значення <em>a</em>, лічильник ітерацій збільшується на 1.
</p>
<p>
    Для визначення глибини рекурсії та загальної кількості викликів створюється дві глобальні змінні: depth та call-counter. Значення call-counter збільшується на 1, при кожному виклику функції, а змінна 
    depth - коли було досягнуто нового значення максимальної глибини.
</p>
<p>
    Час визначається через обгортання виклику функції в блоки <strong>current-inexact-milliseconds</strong>. Пошук глибини рекурсії, кількості викликів та часу зручно визначати у функції-обгортці, яка приймає 
    один з варіантів реалізації функції обчислення n-ого елемента послідовності Фібоначчі.
</p>
<p>
    Для виведення перших m елементів послідовності, зручно реалізувати додаткову фунцію, яка подібна до хвостової, де на кожній ітерації виводиться поточне значення a. 
    Якщо досягнутно <em>m</em> кількості ітерації, то функція завершується.
</p>

<h4>Завдання 2</h4>

<p>
    Для виконання даного завдання необхідно створити функцію, яка при кожному виклику зчитує з консолі число. Якщо було введено число 0, то функція пише у консоль повідомлення "END", що повідомляє про завершення роботи, 
    інакше функція повторно викликає себе, але перед цим, якщо введене число парне, що визначається через функцію <strong>even?</strong>, то воно повторно виводиться у консоль. 
</p>
            </details>
            <details id="hipo" open>
                <summary>HIPO Діаграма</summary>
                
            </details>
            <details id="code-section" open>
                <summary>Код</summary>
                <div id="code-wrapper-container">
                    <code class="code">
                        <div class="copy-code-top-container">
                            Code: Task1
                            <button class="copy-code-btn">
                                <img class="copy-code-icon" src="assets/copy-icon.svg">
                            </button>
                        </div>
                        
                        <pre class="code-text">#lang racket

(displayln "Лаб 1 (Варіант 11) - Завданя 1")
(displayln "Виконав - Сергійчук Дмитро (Підгрупа 6)")

(display "m = ")
(define m (read))

(display "n = ")
(define n (read))

(newline)

(define depth 0)
(define call-counter 0)

(define (f-default n current-depth)
  (set! call-counter (+ call-counter 1))
  (set! current-depth (+ current-depth 1))
  (set! depth (max depth current-depth))
  (if (< n 2)
    1
    (+ (f-default (- n 2) current-depth)
       (f-default (- n 1) current-depth))))

(define (f-tail n current-depth)
  (set! call-counter (+ call-counter 1))
  (set! current-depth (+ current-depth 1))
  (define (iter a b current)
    (set! call-counter (+ call-counter 1))
    (set! current-depth (+ current-depth 1))
    (set! depth (max depth current-depth))
    (if (>= current n)
      a
      (iter (+ a b) a (+ current 1))))
  (iter 1 1 1))

(define (f-iter n current-depth)
  (set! call-counter (+ call-counter 1))
  (set! current-depth (+ current-depth 1))
  (f-iter-func 1 1 1 current-depth))

(define (f-iter-func a b current current-depth)
    (set! call-counter (+ call-counter 1))
    (set! current-depth (+ current-depth 1))
    (set! depth (max depth current-depth))
    (if (>= current n)
      a
      (f-iter-func (+ a b) a (+ current 1) current-depth)))


(define (runner func type)
  (set! depth 0)
  (set! call-counter 0)
  (printf "Type: ~a\n----------------\n" type)

  (define start (current-inexact-milliseconds))
  (define result (func n 0))
  (define end (current-inexact-milliseconds))
  (define elapsed (- end start))

  (printf "Result: ~a\n" result)
  (printf "Depth: ~a\n" depth)
  (printf "Calls ~a\n" call-counter)
  (printf "Time ~a (ms)\n" elapsed)
  (newline))

(runner f-default "Default")
(runner f-tail "Tail")
(runner f-iter "Iteration Process")

(define (print-seq a b current)
  (cond
    [(< current m)
      (begin
        (printf "~a: ~a\n" current a)
        (print-seq (+ a b) a (+ current 1)))]))

(printf "First ~a elements of Fibonacci sequence:\n" m)
(print-seq 1 0 0)</pre>
                    </code>

                    <code class="code code-2">
                        <div class="copy-code-top-container">
                            Code: Task 2
                            <button class="copy-code-btn">
                                <img class="copy-code-icon" src="assets/copy-icon.svg">
                            </button>
                        </div>
                        
                        <pre class="code-text code-text-2">#lang racket

(displayln "Лаб 1 (Варіант 11) - Завданя 2")
(displayln "Виконав - Сергійчук Дмитро (Підгрупа 6)")

(define (f)
  (define num (read))
  (cond
    [(= 0 num) (display "END")]
    [(even? num)
      (printf "~a\n" num)
      (f)] 
    (else (f))))
  
(f)</pre>
                    </code>
                </div>
            </details>
            <details id="results" open>
                <summary>Результати</summary>
                <img src="assets/images/lab1-result1.png">
<img src="assets/images/lab1-result1 (2).png">
<img src="assets/images/lab1-result2.png">
            </details>
            <details id="validation" open>
                <summary>Перевірка</summary>
                <h4>Завдання 1</h4>

<p>
    Для перевірки коректності побудови послідовності візьмемо приклад послідовності зі статті з 
    <a href="https://uk.wikipedia.org/wiki/Послідовність_Фібоначчі">вікіпедії</a>. 
    Ми можемо побачити, що всі 10 елементів, які було стврено у програмі, відповідають прикладу.
</p>

<img src="assets/images/lab1-validation1.png" />

<p>
    Далі було продемонстровано пошук n-ого елемента послідовності. Змінній <em>n</em> було присвоєно значення 5. 
    В даній реалізації, змінна <em>n</em> позначає індекс елемента в послідовності, тому в даному випадку буде знайдено 6 елемент. 
    Результат пошуку повернув число 8, що відповідає 6 елементу послідовності, що можна перевірити за результатом виведення перших 10 елементів.   
</p>

<h4>Завдання 2</h4>

<p>
    При кожному введені парного числа, програма повторно виводить їх у консоль, як і було вказано в умові. 
    Програма не виконує повторне виведення непарних чисел. При введені 0, програма виводить повідомлення END, що завершує роботу.
</p>
            </details>
            <details id="ai" open>
                <summary>Перевірка коду ШІ</summary>
                <h4>Завдання 1</h4>

<p>Було використано ChatGPT</p>

<p>✅ Плюси:</p>
<ul>
    <li>Є чітке розділення між різними реалізаціями обчислення Фібоначчі (звичайна рекурсія, хвостова рекурсія,
        ітеративний підхід).</li>
    <li>Використовується runner для уніфікованого запуску та замірів — це добре для уникнення дублювання коду</li>
    <li>Є вивід проміжної статистики (глибина, кількість викликів, час).</li>
    <li>Логіка зрозуміла навіть без коментарів.</li>
</ul>

<p>⚠️ Мінуси (що шкодить clean code):</p>

<ol>
    <li>
        Глобальні змінні
        <ul>
            <li>depth і call-counter змінюються через set! з будь-якого місця. Це робить код менш передбачуваним і важче
                тестованим.</li>
            <li>Краще повертати їх як результат функції або загортати в структуру (наприклад, (values result depth
                calls) чи struct).</li>
        </ul>
    </li>
    <li>
        Зайві аргументи
        <ul>
            <li>У f-default, f-tail, f-iter ти передаєш current-depth, але він використовується тільки для обліку
                викликів, а не для логіки Фібоначчі. Це робить API функцій "засміченим".</li>
            <li>Логіку підрахунків можна винести в обгортку або в окремий модуль.</li>
        </ul>
    </li>
    <li>
        Дублювання коду
        <ul>
            <li>Усі три варіанти повторюють однаковий код для set! call-counter, set! current-depth, set! depth.</li>
        </ul>
    </li>
    <li>
        Непослідовність у стилі
        <ul>
            <li>В одному місці використовується cond, в іншому — if, хоча логіка схожа.</li>
            <li>Місцями є begin, який можна замінити на акуратнішу конструкцію.</li>
        </ul>
    </li>
    <li>
        Назви функцій
        <ul>
            <li>f-default, f-tail, f-iter — зрозуміло, але назви можна зробити більш інформативними, наприклад:
                <ul>
                    <li>fib-naive (звичайна рекурсія)</li>
                    <li>fib-tail (хвостова рекурсія)</li>
                    <li>fib-iter (ітеративна реалізація).</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>
        print-seq
        <ul>
            <li>Також використовує рекурсію для простого друку, але вона тут зайва. Логічніше було б використати for або
                for/fold.</li>
        </ul>
    </li>
</ol>

<p>🛠 Як можна покращити</p>

<div id="code-wrapper-container">
    <code class="code">
        <div class="copy-code-top-container">
            Code
            <button class="copy-code-btn">
                <img class="copy-code-icon" src="assets/copy-icon.svg">
            </button>
        </div>
        
        <pre class="code-text">
(define (fib-naive n)
  (if (< n 2)
      1
      (+ (fib-naive (- n 1)) (fib-naive (- n 2)))))

(define (fib-tail n)
  (define (iter a b i)
    (if (>= i n)
        a
        (iter (+ a b) a (+ i 1))))
  (iter 1 1 1))

(define (fib-iter n)
  (define (loop a b i)
    (if (>= i n)
        a
        (loop (+ a b) a (+ i 1))))
  (loop 1 1 1))
        </pre>
    </code>
</div>

<p>А для підрахунків можна зробити окрему функцію-обгортку:</p>

<div id="code-wrapper-container">
    <code class="code">
        <div class="copy-code-top-container">
            Code
            <button class="copy-code-btn">
                <img class="copy-code-icon" src="assets/copy-icon.svg">
            </button>
        </div>
        
        <pre class="code-text">
(define (measure func n)
  (define start (current-inexact-milliseconds))
  (define result (func n))
  (define elapsed (- (current-inexact-milliseconds) start))
  (values result elapsed))
        </pre>
    </code>
</div>

<p>👉 Висновок:</p>
<p>Твій код зрозумілий і робочий, але з точки зору clean code він має:</p>
<ul>
    <li>надмірність (повторення одного і того ж коду для підрахунків),</li>
    <li>глобальний стан (depth, call-counter),</li>
    <li>зайві параметри (current-depth).</li>
</ul>
<p>Тобто він швидше "академічний" (добрий для експериментів і наочності), ніж "production-ready" clean code.</p>

<h4>Завдання 2</h4>

<p>Було використано ChatGPT</p>

<p>✅ Плюси:</p>
<ul>
    <li>Пряма логіка: три випадки (0, парне, інше).</li>
    <li>Менше вкладеності: немає зайвих begin.</li>
    <li>Використання cond по суті: кілька гілок — доречно.</li>
    <li>Рекурсія оформлена акуратно — зрозуміло, що йде повторне читання.</li>
</ul>

<p>⚠️ Мінуси щодо clean code:</p>
<ul>
    <li>Назва f: Нічого не каже про призначення. Краще process-numbers або print-evens-until-zero.</li>
    <li>Подвійний виклик f: У гілках (even? num) та else є повторення (f). Це дублювання коду, яке можна винести</li>
    <li>Форматування: У гілці (even? num) команди написані в один блок, але їх можна оформити акуратніше для кращої
        читабельності.</li>
</ul>

<p>🛠 Варіант чистіший:</p>

<div id="code-wrapper-container">
    <code class="code">
        <div class="copy-code-top-container">
            Code
            <button class="copy-code-btn">
                <img class="copy-code-icon" src="assets/copy-icon.svg">
            </button>
        </div>
        
        <pre class="code-text">
#lang racket

(define (process-numbers)
    (define num (read))
    (cond
    [(zero? num) (displayln "END")]
    [else
        (when (even? num)
        (printf "~a\n" num))
        (process-numbers)]))

(process-numbers)
        </pre>
    </code>
</div>
            </details>
            <details id="conclusion" open>
                <summary>Висновок</summary>
                <p>
    В даній роботі було продемонстровано реалізації звичайної рекурсії, хвостої та ітеративного процесу. Відповідно до отриманих результатів було визначено, що для пошуку 
    елементів з послідовності Фібоначчі, хвостова рекурсія та ітеративний процес (який в даному випадку не відрізняється від хвостової рекурсії) виконуються значно швидше, 
    оскільки виконується менше викликів функцій. Глибина рекурсії у звичайній рекурсії менша на 1, та відповідає значення n, що пояснюється тим, що інші методи мають вкладену функцію, що 
    додає один додатковий виклик для функції-обгортки.
</p>
            </details>
        </main>
    </div>

    <script src="assets/script.js"></script>
</body>

</html>