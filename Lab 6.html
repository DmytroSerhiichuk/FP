<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="assets/style.css">
    <title>Lab 6</title>
</head>

<body>
    <div class="navigation-container">
        <nav class="lab-nav">
            <a href="index.html">Титулка</a>
            <a href="Lab 1.html">Lab 1</a>
            <a href="Lab 2.html">Lab 2</a>
            <a href="Lab 3.html">Lab 3</a>
            <a href="Lab 4.html">Lab 4</a>
            <a href="Lab 5.html">Lab 5</a>
            <a href="Lab 6.html">Lab 6</a>
        </nav>

        <nav class="page-nav">
            <a href="#goal">Мета</a>
            <a href="#conditions">Умова</a>
            <a href="#analysis">Аналіз</a>
            <a href="#hipo" id="hipo-ref">HIPO Діаграма</a>
            <a href="#code-section">Код</a>
            <a href="#results">Результати</a>
            <a href="#validation">Перевірка</a>
            <a href="#ai">Перевірка коду ШІ</a>
            <a href="#conclusion">Висновок</a>
        </nav>
    </div>

    <header>
        <h1>Lab 6</h1>
    </header>

    <div id="main-wrapper">
        <main>
            <details id="goal" open>
                <summary>Мета</summary>
                <p>Опанувати теоретичні основи обробки структур типу векторів і матриць, стеків та черг мовами функціонального програмування та розробити програми їх реалізації</p>
            </details>
            <details id="conditions" open>
                <summary>Умова</summary>
                <img src="assets/images/lab6-conditions.png" alt="">
            </details>
            <details id="analysis" open>
                <summary>Аналіз</summary>
                <h4>Завдання 1</h4>

<p>
    Для забезпечення чергування елементів, було реалізовано функцію, яка приймає 
    вектор та функцію, яка перевіряє, чи перевіряє даний елемент умові. Також ще 
    одним аргументом є індекс попереднього елемента, що відповідає умові. Таким 
    чином ми можемо по черзі виконувати пошук наступного числа, більшого за нуль, 
    а потім - меншого за нуль
</p>

<h4>Завдання 2</h4>

<p>
    Для роботи з чергами можна використовувати пакет <strong>data/queue</strong>. 
    Він вже має багато зручних методів для роботи з чергами, проте для даного 
    завдання, ще можна додати отримання останнього елемента черги. Це можна 
    реалізувати перетворивши чергу в список, обернути його та взяти перший 
    елемента через функцію <strong>car</strong>
</p>
            </details>
            <details id="hipo" open>
                <summary>HIPO Діаграма</summary>
                <h4>Завдання 1</h4>

<img src="assets/images/lab6-hipo1.png" alt="">

<h4>Завдання 2</h4>

<img src="assets/images/lab6-hipo2.png" alt="">
            </details>
            <details id="code-section" open>
                <summary>Код</summary>
                <div id="code-wrapper-container">
                    <code class="code">
                        <div class="copy-code-top-container">
                            Code: Task1
                            <button class="copy-code-btn">
                                <img class="copy-code-icon" src="assets/copy-icon.svg">
                            </button>
                        </div>
                        
                        <pre class="code-text">#lang racket

(displayln "Лаб 6 (Варіант 11) - Завданя 1")
(displayln "Виконав - Сергійчук Дмитро (Підгрупа 6)")
(newline)

; Перевіряє, чи вектор складається лише з чисел
(define (number-vector? vec [index 0])
  (if (< index (vector-length vec))
    (if (number? (vector-ref vec index)) 
      (number-vector? vec (+ index 1)) 
      #f)
    #t))

; Читає вектор з консолі, перевіряючи вхідні дані на коректність
(define (read-vector)
  (printf "Введіть вектор: ")
  (define vec (read))
  (cond
    [(and (vector? vec) (number-vector? vec)) vec]
    [else
     (printf "Некоректні вхідні дані\n")
     (read-vector)]))

; Прибирає елементи з вектора, які є нулями
(define (remove-zeros vec)
  ; Ітерує вектор та виконує фільтрацію
  ; - filtered-vector : акумулятор-вектор без нульових елементів
  ; - index           :  індекс поточної ітерації
  (define (iterate [filtered-vector #()] [index 0])
    (cond
      [(< index (vector-length vec))
       (define elem (vector-ref vec index))
       (define next-vec (if (zero? elem)
                            filtered-vector
                            (vector-append filtered-vector (vector elem))))
       (iterate next-vec (+ index 1))]
      [else filtered-vector]))
  (iterate))

; Повертає індекс наступного елемента, який відповідає умові:
; - vec        : вхідний вектор
; - prev-index : індекс попереднього елемента, який відповідає умові
; - condition? : функція, яка перевіряє відповідність елемента умові
; Повертає індекс елемента або #false якщо досягнуто кінець вектора
(define (get-next-elem-index-with-condition vec prev-index condition?)
  (define (iterate [index (+ prev-index 1)])
    (cond
      [(< index (vector-length vec))
        (if (condition? (vector-ref vec index))
          index
          (iterate (+ index 1)))]
      [else #f]))
  (iterate))

; Впорядковує вектор таким чином, щоб знак елементів чергувався (плюс - мінус)
(define (arrange-vector vec)
  ; Ітерує вектор та впорядкою його
  ; - arranged-vector     : акумулятор, що репрезентує впорядкований вектор
  ; - prev-signed-index   : індекс попереднього елемента, який < 0
  ; - prev-unsigned-index : індекс попереднього елемента, який >= 0
  ; - sign                : знак числа, на даній ітерації
  (define (do-arrange [arranged-vector #()] [prev-signed-index -1] [prev-unsigned-index -1] [sign #f])
    (cond
      [(or prev-signed-index prev-unsigned-index)
        (cond
          [sign
            (define next-signed-index (get-next-elem-index-with-condition vec prev-signed-index (lambda (elem) (< elem 0))))
            (define next-vec (if next-signed-index
                                 (vector-append arranged-vector (vector (vector-ref vec next-signed-index)))
                                 arranged-vector))
             (do-arrange 
                next-vec
                next-signed-index 
                prev-unsigned-index
                (if prev-unsigned-index #f #t))]
          [else
            (define next-unsigned-index (get-next-elem-index-with-condition vec prev-unsigned-index (lambda (elem) (>= elem 0))))
            (define next-vec (if next-unsigned-index
                                 (vector-append arranged-vector (vector (vector-ref vec next-unsigned-index)))
                                 arranged-vector))
            (do-arrange 
                next-vec
                prev-signed-index 
                next-unsigned-index
                (if prev-signed-index #t #f))])]
      [else arranged-vector]))
  (do-arrange))

(define my-vector (read-vector))
(newline)
(define vector-without-zeros (remove-zeros my-vector))
(printf "Вектор без нулів: ~a\n" vector-without-zeros)
(define arranged-vector (arrange-vector vector-without-zeros))
(printf "Впорядкований вектор: ~a\n" arranged-vector)</pre>
                    </code>

                    <code class="code code-2">
                        <div class="copy-code-top-container">
                            Code: Task 2
                            <button class="copy-code-btn">
                                <img class="copy-code-icon" src="assets/copy-icon.svg">
                            </button>
                        </div>
                        
                        <pre class="code-text code-text-2">#lang racket
(require data/queue)

(displayln "Лаб 6 (Варіант 11) - Завданя 2")
(displayln "Виконав - Сергійчук Дмитро (Підгрупа 6)")
(newline)

; Читає з консолі не дробове число, що більше 0
(define (read-exact-number)
	(define num (read))
	(cond
		[(and (number? num) (> num 0) (exact? num)) num]
		[else (printf "Введено некоректні дані\n") (read-exact-number)]))

; Повертає випадкове ціле число від 1 до max включно
(define (random-int max)
	(inexact->exact (+ 1 (floor (* (random) max)))))

; Збільшеє значення символа на 1
(define (increment-char char)
	(integer->char (+ 1 (char->integer char))))

; Заповнює чергу покупцями, які мають такий вигляд: (Ідентифікатор . К-сть товарів)
; - size: кількість елементів, які необхідно додати
; - max-number-of-products: максимальна кількість товарів у клієнта
; - name: ідентифікатор поточного покупця
; - index: індекс поточної ітерації
(define (generate-queue size max-number-of-products [name #\A] [index 0])
  (when (< index size)
		(enqueue! queue (cons name (random-int max-number-of-products)))
		(define next-name (increment-char name))
		(generate-queue size max-number-of-products next-name (+ index 1))))

; Виводить чергу в консоль
(define (print-queue q)
	(displayln (queue->list q)))

; Моделює чергу в магазині
; - q: черга покупців
; - iter: поточна ітерація
(define (model q [iter 0])
	(cond 
		[(not (queue-empty? q))
			(printf "Ітерація: ~a\n" (+ 1 iter))
			(define client (dequeue! q))
			(printf "Зараз обслуговується клієнт: ~a\n" client)
			(define served-client (cons (car client) (- (cdr client) 1)))

			(cond
				[(zero? (cdr served-client))
					(printf "Клієнта ~a було обслужено, він покидає чергу\n" (car served-client))]
				[else 
					(printf "У клієнта ~a залишилося ~a товарів, він повертається в кінець черги\n" (car served-client) (cdr served-client))
					(enqueue! q served-client)])

			(printf "Черга на кінець даної ітерації: ")
			(print-queue q)
			(newline)
			(model q (+ iter 1))]
		[else iter]))

(define queue (make-queue))

(displayln "Введіть початковий розмір черги:")
(define queue-size (read-exact-number))
(displayln "Введіть максимальну кількість товарів у покупця:")
(define max-number-of-products (read-exact-number))
(newline)

(generate-queue queue-size max-number-of-products)

(printf "Початкова черга: ")
(print-queue queue)
(newline)

(define iterations (model queue))
(printf "Було пройдено ~a ітерацій" iterations)</pre>
                    </code>
                </div>
            </details>
            <details id="results" open>
                <summary>Результати</summary>
                <h4>Завдання 1</h4>

<img src="assets/images/lab6-result1.png" alt="">

<h4>Завдання 2</h4>

<img src="assets/images/lab6-result2.png" alt="">
            </details>
            <details id="validation" open>
                <summary>Перевірка</summary>
                <p>Завдання не потребують перевірки</p>
            </details>
            <details id="ai" open>
                <summary>Перевірка коду ШІ</summary>
                <h4>Завдання 1</h4>

<p>Введний запит: "чи відповідає даний код на мові програмування racket критеріям простоти та clean code? (код завдання №1)"</p>

<p>Відповідь Chat GPT:</p>

<p>Код виглядає акуратно й добре структуровано, але якщо оцінювати його з точки зору принципів простоти та clean code, то є як позитивні сторони, так і моменти, які можна покращити. Розберімо детально 👇</p>

<p>✅ Позитивні сторони</p>

<ol>
    <li>
        <p>Чіткі коментарі</p>
        <p>Кожна функція має зрозумілий опис: призначення, параметри, очікуваний результат. Це чудово для читабельності, особливо в Racket, де структура рекурсій може бути заплутаною.</p>
    </li>
    <li>
        <p>Хороше розділення обов’язків</p>
        <p>Кожна функція робить щось одне:</p>
        <ul>
            <li>number-vector? — перевіряє тип даних</li>
            <li>read-vector — читає і валідує введення</li>
            <li>remove-zeros — очищує вектор</li>
            <li>arrange-vector — чергує знаки</li>
        </ul>
        <p>Це відповідає Single Responsibility Principle</p>
    </li>
    <li>Функціональний підхід з рекурсією реалізовано грамотно — без зайвих побічних ефектів, немає глобальних змінних</li>
    <li>Використання локальних допоміжних функцій (iterate, do-arrange) — гарна практика для ізоляції логіки та збереження чистоти коду</li>
</ol>

<p>⚠️ Моменти, які можна покращити</p>

<ol>
    <li>
        <p>Зайва складність у arrange-vector</p>
        <p>Функція дуже важка для сприйняття:</p>
        <ul>
            <li>вона одночасно веде три індекси (prev-signed-index, prev-unsigned-index, sign)</li>
            <li>має вкладену рекурсію та логіку з багатьма умовами</li>
        </ul>
        <p>🟢 Порада:</p>
        <p>Розбий функцію на дрібніші:</p>
        <ul>
            <li>окрема функція find-next-positive</li>
            <li>окрема find-next-negative</li>
            <li>і головна, яка просто чергує їх.</li>
        </ul>
        <p>Це зменшить когнітивне навантаження й дозволить уникнути дублювання коду.</p>
    </li>
    <li>
        <p>Надлишковість у number-vector?</p>
        <p>Тут можна використати вбудовані засоби, щоб зробити код коротшим і чистішим:</p>

        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                
                <pre class="code-text">
(define (number-vector? vec)
  (and (vector? vec)
       (for/and ([x (in-vector vec)]) (number? x))))
                </pre>
            </code>
        </div>

        <p>— без явної рекурсії, з тією ж логікою.</p>
    </li>
    <li>
        <p>remove-zeros можна спростити:</p>
        <p>Твоя версія рекурсивна, але це можна зробити декларативно:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                
                <pre class="code-text">
(define (remove-zeros vec)
  (vector-filter (λ (x) (not (zero? x))) vec))
                </pre>
            </code>
        </div>
        <p>Це значно коротше, легше читається і працює так само.</p>
    </li>
    <li>
        <p>read-vector має побічний ефект (рекурсивне самовикликання)</p>
        <p>Це не критично, але якщо говорити про "clean code", то краще відділяти читання від перевірки даних:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                
                <pre class="code-text">
(define (read-vector)
  (let loop ()
    (printf "Введіть вектор: ")
    (define vec (read))
    (if (and (vector? vec) (number-vector? vec))
        vec
        (begin
          (printf "Некоректні вхідні дані\n")
          (loop)))))
                </pre>
            </code>
        </div>
        <p>Так код читається плавніше (і без повторного виклику самої функції по імені).</p>
    </li>
    <li>
        <p>Назви змінних і функцій</p>
        <p>Назви в цілому гарні, але arranged-vector і do-arrange трохи розмиті.</p>
        <p>Можна чіткіше:</p>
        <ul>
            <li>arrange-alternating-signs</li>
            <li>build-alternating-vector</li>
        </ul>
        <p>Це зробить намір функції очевидним навіть без читання коментарів.</p>
    </li>
</ol>

<h4>Завдання 2</h4>

<p>Введний запит: "чи відповідає даний код на мові програмування racket критеріям простоти та clean code? (код завдання №2)"</p>

<p>Відповідь Chat GPT:</p>

<p>✅ Що зроблено добре</p>
<ol>
    <li>
        Чітка структура програми
        <ul>
            <li>Код логічно поділений на функції, кожна з яких виконує одну зрозумілу задачу.</li>
            <li>Імена функцій зрозумілі: read-exact-number, generate-queue, model, print-queue — все інтуїтивно.</li>
        </ul>
    </li>
    <li>
        Коментарі якісні
        <ul>
            <li>Короткі й чітко пояснюють призначення функції та параметри</li>
            <li>Використано формат, подібний до docstring у Python — це гарно</li>
        </ul>
    </li>
    <li>
        Валідація введення
        <ul>
            <li>Функція read-exact-number має перевірку на тип, знак і цілісність — це демонструє увагу до надійності</li>
        </ul>
    </li>
    <li>
        Чистий функціональний стиль
        <ul>
            <li>Рекурсія використана природно для Racket (generate-queue, model).</li>
            <li>Використовуються імунні структури даних та прості операції без зайвих побічних ефектів (окрім enqueue/dequeue, що є необхідним)</li>
        </ul>
    </li>
    <li>
        Добре відокремлені обов’язки
        <ul>
            <li>Є функції для вводу, генерації, виводу та моделювання</li>
            <li>Основна логіка не перемішана з побічними діями (наприклад, друком)</li>
        </ul>
    </li>
</ol>

<p>⚠️ Що можна покращити</p>
<ol>
    <li>
        <p>Неочевидна глобальна змінна queue</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                <pre class="code-text">
(define queue (make-queue))
                </pre>
            </code>
        </div>
        <p>→ Цю змінну краще передавати як параметр до generate-queue, щоб уникати глобального стану.</p>
        <p>Чому: глобальні змінні зменшують модульність і повторне використання коду.</p>
        <p>✅ Кращий варіант:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                <pre class="code-text">
(define (generate-queue size max-number-of-products [name #\A] [index 0] [q (make-queue)])
  (when (< index size)
    (enqueue! q (cons name (random-int max-number-of-products)))
    (generate-queue size max-number-of-products (increment-integer name) (+ index 1) q))
  q)
                </pre>
            </code>
        </div>
        <p>Тоді виклик:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                <pre class="code-text">
(define queue (generate-queue queue-size max-number-of-products))
                </pre>
            </code>
        </div>
    </li>
    <li>
        <p>Надлишкове дублювання логіки у model</p>
        <p>Блок:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                <pre class="code-text">
(printf "Ітерація: ~a\n" (+ 1 iter))
...
(printf "Черга на кінець даної ітерації: ")
(print-queue q)
(newline)
                </pre>
            </code>
        </div>
        <p>можна винести у допоміжну функцію, щоб model стала компактнішою.</p>
    </li>
    <li>
        <p>Можна спростити умову у read-exact-number</p>
        <p>Зараз вона трохи громіздка:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                <pre class="code-text">
(and (number? num) (> num 0) (exact? num))
                </pre>
            </code>
        </div>
        <p>✅ Можна зробити більш читабельно:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                <pre class="code-text">
(define (positive-exact-integer? n)
  (and (exact? n) (integer? n) (> n 0)))
                </pre>
            </code>
        </div>
        <p>і потім:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                <pre class="code-text">
(when (not (positive-exact-integer? num))
  ...)
                </pre>
            </code>
        </div>
    </li>
    <li>
        <p>Можна уникнути рекурсії для моделювання</p>
        <p>Функція model рекурсивна, але це можна реалізувати через цикл (for чи let loop), що спростить розуміння логіки та зменшить навантаження на стек:</p>
        <div id="code-wrapper-container">
            <code class="code">
                <div class="copy-code-top-container">
                    Code
                    <button class="copy-code-btn">
                        <img class="copy-code-icon" src="assets/copy-icon.svg">
                    </button>
                </div>
                <pre class="code-text">
(let loop ([q queue] [iter 0])
  (unless (queue-empty? q)
    ...
    (loop q (+ iter 1))))
                </pre>
            </code>
        </div>
        <p>Хоча для Racket рекурсія — норма, у цьому випадку цикл виглядав би природніше</p>
    </li>
</ol>
            </details>
            <details id="conclusion" open>
                <summary>Висновок</summary>
                <p>
    В даній роботі було продемонстровано роботу з векторами та чергами в racket. 
    В першому завданні, яке вимагає роботу з векторами, максимально уникалося 
    використання списків, надаючи перевагу функціям роботи з векторами. Для 
    другого завдання використовувалися черги з пакету data/queue
</p>
            </details>
        </main>
    </div>

    <script src="assets/script.js"></script>
</body>

</html>